---
slug: cww-2023
title: Топ рекомендаций по Core Web Vitals на 2023 год
description: Топ рекомендаций по Core Web Vitals на 2023 год
authors: harryheman
tags: [html, css, javascript, seo, search engine optimization, core web vitals, web vitals, cwv]
---

Привет, друзья!

Представляю вашему вниманию перевод [этой замечательной статьи](https://web.dev/top-cwv-2023/), представляющей собой коллекцию лучших практик, которые по мнению команды Chrome DevRel являются наиболее эффективными способами улучшения показателей Core Web Vitals.

Core Web Vitals - это часть метрик Web Vitals, используемых для оценки веб-страниц и включенных во все инструменты Google. Владельцы сайтов должны учитывать эти метрики. Каждый показатель Core Web Vitals представляет собой отдельный аспект опыта взаимодействия пользователя с сайтом, измеряемый в полевых условиях и отражающий реальные действия по достижению критически важного результата, [ориентированного на пользователя](https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured).

Web Vitals - это инициатива Google, цель которой - предоставить единое руководство по сигналам качества, необходимым для обеспечения хорошего взаимодействия с пользователем в Интернете ([источник](https://web.dev/vitals/)).

<!--truncate-->

Текущий набор метрик Core Web Vitals фокусируется на трех аспектах взаимодействия с пользователем: скорости загрузки страниц сайта, интерактивности и визуальной стабильности, и включает следующие показатели (и их соответствующие пороговые значения):

<img src="https://habrastorage.org/webt/nl/a5/di/nla5di_6rntrvqw6sl0vssnjs2w.png" />
<br />

- [Largest Contentful Paint (LCP) - Скорость загрузки основного контента](https://web.dev/lcp/): измеряет производительность загрузки. Чтобы обеспечить удобство работы пользователей, показатель LCP должен быть в пределах 2,5 секунды от начала загрузки страницы.

<img src="https://habrastorage.org/webt/8e/fl/-p/8efl-p0vlruxipglvrpy_yrmufa.png" />
<br />

- [First Input Delay (FID) - Время ожидания до первого взаимодействия с контентом](https://web.dev/fid/): измеряет интерактивность. Показатель FID у страниц не должен превышать 100 миллисекунд.

<img src="https://habrastorage.org/webt/kj/sb/3c/kjsb3cbvoipfw8fomxecmn8teps.png" />
<br />

- [Cumulative Layout Shift (CLS) - Совокупное смещение макета](https://web.dev/cls/): измеряет визуальную стабильность. Показатель CLS не должен превышать 0,1.

Недавно в CWV была добавлена еще одна метрика - [Interaction to Next Paint (INP) - Интерактивность до следующей отрисовки](https://web.dev/inp/): измеряет интерактивность на протяжении всего времени посещения пользователем страницы. Данная метрика пока считается экспериментальной. Показатель INP не должен превышать 200 миллисекунд.

<img src="https://habrastorage.org/webt/wl/hh/gm/wlhhgmcuz7dulltpfmsl0kvae-i.png" />
<br />

Хотя показатели Core Web Vitals являются критически важными для понимания и обеспечения хорошего взаимодействия с пользователем, существуют и другие важные метрики.

Они часто служат в качестве промежуточных или дополнительных показателей для Core Web Vitals, и помогают полнее охватить взаимодействие с пользователем или диагностировать конкретную проблему.

Например, метрики [Time to First Byte (TTFB) - Время до первого байта](https://web.dev/ttfb/) и [First Contentful Paint (FCP) - Первая отрисовка контента](https://web.dev/fcp/) являются критически важными аспектами загрузки и полезны для диагностики проблем с LCP (медленное время отклика сервера или ресурсы, блокирующие рендеринг).

Аналогично, такие показатели, как [Total Blocking Time (TBT) - Общее время блокировки](https://web.dev/tbt/) и [Time to Interactive (TTI) - Время до интерактивности](https://web.dev/tti/), являются крайне важными метриками для выявления и диагностики потенциальных проблем с интерактивностью, которые могут повлиять на FID. Однако они не входят в набор Core Web Vitals, потому что не поддаются измерению в полевых условиях и не отражают результаты, ориентированные на пользователя.

Приведенный ниже список рекомендаций по повышению веб-производительности акцентирует внимание на трех вещах:

- наибольшее влияние в реальном мире;
- актуальность и применимость к большинству сайтов;
- реализуемость большинством разработчиков.

## Largest Contentful Paint (LCP)

На сегодняшний день лишь [около половины](https://datastudio.google.com/s/nw4gcbKA5o4) сайтов в Интернете удовлетворяет пороговому значению LCP.

### Ресурс LCP должен находиться в HTML

Согласно [Web Almanac 2022](https://almanac.httparchive.org/en/2022/), подготовленного HTTP Archive, [72%](https://almanac.httparchive.org/en/2022/performance#fig-8) мобильных страниц содержат изображение в качестве элемента LCP. Это означает, что быстрая загрузка этих изображений является критически важной для LCP.

Однако скорость загрузки изображения - это только одна часть задачи. Другой частью является минимальное время до начала загрузки изображения.

[39%](https://almanac.httparchive.org/en/2022/performance#lcp-static-discoverability) источников указанных выше изображений являются недостижимыми в HTML. Другими словами, их URL не были обнаружены в стандартных атрибутах HTML (таких как `<img src="...">` или `<link rel="preload" href="...">`), которые позволяют браузеру быстро обнаружить и начать загрузку изображения.

Если URL изображения недостижим в HTML, значит, страница должна ждать полной загрузки файлов CSS или JavaScript, их разбора (парсинга) и обработки до начала загрузки изображения.

Общая рекомендация: если изображение является элементом LCP, его URL должен находиться в HTML. Этого можно достичь следующим образом:

- __загрузка изображения с помощью элемента `<img>` с атрибутом `src` или `srcset`.__ Не используйте нестандартные атрибуты вроде `data-src`, которые требуют JS для рендеринга. [9%](https://almanac.httparchive.org/en/2022/performance#lcp-lazy-loading) проанализированных страниц скрывают свои LCP изображения за атрибутом `data-src`;
- __используйте server-side rendering (SSR) - рендеринг на стороне сервера вместо client-side rendering (CSR) - рендеринга на стороне клиента__, поскольку SSR возвращает страницу целиком, включая изображения. CSR требует JS для рендеринга страницы, включая изображения;
- __если изображение запрашивается из внешнего файла CSS или JS, для его предварительной загрузки можно использовать тег `<link rel="preload">`__. _Обратите внимание_: ссылка на изображение во встроенных стилях (inline styles) не обнаруживается [сканером предварительной загрузки](https://web.dev/preload-scanner/).

Обеспечение достижимости изображения LCP в разметке приводит не только к улучшению производительности, но также открывает возможность для приоритизации ресурса.

### Ресурс LCP должен быть приоритетным

Ресурс LCP должен быть не только достижим в HTML, он также должен быть [приоритетным](https://web.dev/optimize-lcp/#optimize-the-priority-the-resource-is-given) по сравнению с другими менее важными ресурсами.

Например, если изображение LCP присутствует в HTML, но в `<head>` документа имеется множество тегов `<script>` перед тегом `<img>`, может пройти много времени до начала загрузки изображения.

Простейшим способом решения этой проблемы является установка тегу `<img>` или `<link>`, загружающему изображение LCP, нового атрибута [fetchpriority="high"](https://web.dev/priority-hints/). Это сообщает браузеру о необходимости первоочередной загрузки указанного ресурса.

Согласно Web Almanac только [0,03%](https://almanac.httparchive.org/en/2022/performance#lcp-prioritization) проанализированных страниц используют преимущества нового интерфейса. Хотя атрибут `fetchpriority` в настоящее время поддерживается только браузерами на основе Chromium, его можно рассматривать как прогрессивное улучшение, которое будет просто игнорироваться другими браузерами.

Для браузеров, не поддерживающих `fetchpriority`, единственным способом решения проблемы является размещение тега `<link rel="preload">` перед скриптами в `<head>` или перемещение скриптов в конец `<body>` после тега `<img>`.

Другим важным аспектом приоритизации ресурса LCP является отсутствие вещей, понижающих его приоритет, таких как атрибут `loading="lazy"`. На сегодняшний день [10%](https://almanac.httparchive.org/en/2022/performance#lcp-lazy-loading) страниц устанавливают этот атрибут изображениям LCP. Чаще всего это связано с использованием инструментов для оптимизации изображений, которые применяют "ленивую" (отложенную) загрузку (lazy-loading) ко всем изображениям.

Еще одним способом повышения приоритета ресурса LCP является задержка загрузки некритических ресурсов (их отложенная загрузка). Например, загрузка скриптов, которые не участвуют в формировании пользовательского интерфейса (такие как аналитика или виджеты социальных сетей), может быть отложена до возникновения события `load`, чтобы они не уменьшали пропускную способность сети для важных ресурсов (таких как изображения LCP).

Лучшие практики по быстрой загрузке ресурса LCP с высоким приоритетом могут быть сведены к следующему:

- __добавляем атрибут `fetchpriority="high"` к тегу `<img>`, загружающему изображение LCP.__ Если ресурс загружается с помощью тега `<link rel="preload">`, ему также можно установить `fetchpriority="high"`;
- __никогда не устанавливаем атрибут `loading="lazy"` тегу `<img>`, загружающему изображение LCP.__ Это снижает приоритет загрузки изображения, т.е. откладывает начало его загрузки;
- __откладываем загрузку некритических ресурсов.__ Перемещаем их в конец документа, используем нативные механизмы ленивой загрузки для изображений и фреймов или загружаем их асинхронно с помощью JS.

### Использование CDN для оптимизации TTFB документа и ресурса

Последним кусочком пазла является обеспечение максимально быстрого ответа на первоначальный запрос документа. Браузер не может начать загрузку ресурсов до получения первого байта ответа на такой запрос.

Это время известно как TTFB и лучшим способом его уменьшения является следующее:

- обслуживать контент максимально близко (географически) к пользователю;
- кэшировать контент для недавно запрошенных ресурсов для ускорения повторного ответа.

Лучшим способом решения этих задач является использование [CDN](https://web.dev/content-delivery-networks/). CDN распределяют ресурсы по нескольким серверам, которые находятся в разных местах земного шара. Это уменьшает расстояние, которое должен пройти ресурс до пользователя. CDN также, как правило, имеют отличные механизмы кэширования, которые могут быть кастомизированы и оптимизированы для нужд вашего сайта.

Многие разработчики используют CDN для обслуживания статических ресурсов. Однако CDN могут также обслуживать и кэшировать документы HTML, даже в случае их динамической генерации.

Согласно Web Almanac только [29%](https://almanac.httparchive.org/en/2022/cdn#cdn-adoption) документов HTML обслуживаются CDN.

Несколько трюков по настройке CDN:

- рассмотрите возможность увеличения времени кэширования (обязательно ли контент должен быть всегда свежим? Или он может обновляться один раз в несколько минут?);
- рассмотрите возможность совместного кэширования нескольких ресурсов и их одновременного обновления;
- рассмотрите возможность использования [граничных вычислений](https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F) для сложной логики, выполняющейся на вашем сервере.

Возможность обслуживать контент с помощью граничных вычислений существенно снижает время ответа. Однако даже если вам необходимо обратиться к серверу для загрузки ресурса, CDN могут сильно помочь в оптимизации этого процесса.

## Cumulative Layout Shift (CLS)

На сегодняшний день около четверти сайтов не удовлетворяют пороговому значению CLS.

### Явные размеры контента

[Сдвиг макета](https://web.dev/cls/#layout-shifts-in-detail) обычно происходит, когда существующий контент сдвигается после завершения загрузки другого контента. Таким образом, основным способом решения этой проблемы является резервирование места для загружаемого контента в количестве, максимально близком к необходимому (тому, который фактически будет занимать загруженный контент).

Одним из очевидных способов предотвращения сдвига макета является установка размеров изображения с помощью атрибутов `width` и `height` (или соответствующих свойств CSS). Однако согласно HTTP Archive [72%](https://almanac.httparchive.org/en/2022/performance#explicit-dimensions) страниц содержат как минимум одно "безразмерное" изображение. Дефолтная высота таких изображений, устанавливаемая браузером, составляет `0px`, что может привести к заметному сдвигу макета после загрузки изображения и вычисления его размеров.

Важно помнить, что сдвиги макета вызываются не только изображениями. Они также могут вызываться контентом, который загружается после первоначального рендеринга страницы, например, рекламой или встроенными видео. Справиться с этим может помочь свойство [aspect-ratio](https://web.dev/aspect-ratio/). Это относительно новое свойство CSS позволяет разработчикам определять соотношение сторон изображений и других элементов. Это, в частности, позволяет устанавливать динамическую ширину (например, на основе ширины области видимости), на основе которой браузер автоматически вычисляет соответствующую высоту.

Но что если нам неизвестны даже приблизительные размеры динамического контента? __Установка свойства `min-height`__ почти всегда лучше использования браузером дефолтной высоты пустого элемента, равной `0px`. `min-height` не ограничивает высоту элемента, т.е. если окажется, что контент выше `min-height`, его контейнер просто немного растянется.

### bfcache

Браузеры используют механизм навигации под названием [back/forward cache - bfcache](https://web.dev/bfcache/) для мгновенной доставки страницы из снимка памяти (memory snapshot) истории браузера.

bfcache - это серьезная оптимизация производительности браузера, которая существенно уменьшает сдвиг макета в процессе загрузки страницы. Представление bfcache [стало "наибольшим" улучшением CLS в 2022 году](https://twitter.com/anniesullie/status/1491399685961293828?s=20&t=k7JgTjdO21uMpeOuOofroA).

[Большое число сайтов](https://almanac.httparchive.org/en/2022/performance#bfcache-eligibility) не подходят для применения bfcache, поэтому они не могут воспользоваться этим бесплатным улучшением навигации.

Убедитесь, что ваши страницы [подходят для применения bfcache](https://web.dev/bfcache/#optimize-your-pages-for-bfcache). Chrome предоставляет [тестировщик bfcache в инструментах разработчика](https://web.dev/bfcache/#test-to-ensure-your-pages-are-cacheable). Скоро соответствующий инструмент появится в Lighthouse.

bfcache может улучшить не только CLS, но и другие метрики CWV.

### Анимации и переходы

Другой распространенной причиной сдвигов макета является анимирование элементов. Например, баннеры куки или баннеры с другими уведомлениями, появляющиеся сверху или снизу, часто влияют на CLS. Даже если они не добавляют контент на страницу, их анимирование может влиять на CLS.

Исследования показывают, что CLS страниц, на которых анимируются свойства CSS, влияющие на макет, в среднем, на 15% хуже, чем CLS страниц, которые этого не делают. Одни свойства влияют на CLS хуже, чем другие. Например, очень негативно сказывается на CLS анимирование величины `margin` или ширины `border`.

Это не удивительно, поскольку каждый раз, когда анимируется свойство CSS, влияющее на макет, происходит сдвиг макета, и если эти сдвиги происходят позже 500 миллисекунд с начала взаимодействия пользователя со страницей, они ухудшают CLS.

Это справедливо даже в отношении элементов, изъятых из обычного потока документа. Например, элементы с `position: absolute`, у которых анимируются свойства `top` или `left`, приводят к сдвигам макета. Однако если вместо `top` или `left` мы анимируем `transform: translateX()` или ` transform: translateY()`, это не заставляет браузер пересчитывать макет и не приводит к его сдвигам.

Предпочтение анимации свойств CSS, которые могут обновляться браузером на уровне композиции (compositor thread), давно является [лучшей практикой по повышению производительности](https://web.dev/animations-guide/), поскольку анимация выполняется в GPU, за пределами основного потока (main thread).

Общая рекомендация: никогда не анимируйте и не модифицируйте состояние элемента при переходе с помощью свойств CSS, которые вынуждают браузер обновлять макет страницы до тех пор, пока это не делается в ответ на действие пользователя (только [не с помощью hover](https://web.dev/cls/#user-initiated-layout-shifts)). По-возможности реализуйте анимацию и переходы с помощью свойства `transition`.

## First Input Delay (FID)

Interaction to Next Paint (INP) является потенциальной заменой FID, поэтому указанные ниже рекомендации применимы к обеим метрикам. INP является более строгой, чем FID за счет более длительного времени проведения измерений.

### Длительные задачи

Задача - это любая работа, выполняемая браузером. Задачи включают рендеринг, формирование макета, парсинг, компиляцию и выполнение скриптов. Когда задачи становятся [длительными](https://web.dev/long-tasks-devtools/#what-are-long-tasks) (когда их выполнение длится более 50 миллисекунд), они блокируют основной поток и, как следствие, отклик страницы на действия пользователя.

Длительные (большие) задачи должны [разбиваться на более короткие (мелкие)](https://web.dev/optimize-long-tasks/). Это можно реализовать с помощью [переключения на основной поток](https://web.dev/optimize-long-tasks/#use-asyncawait-to-create-yield-points) (например, с помощью `async/await`) для более быстрого рендеринга обновлений и отклика на действия пользователя.

Другим способом является использование интерфейсов вроде [isInputPending()](https://web.dev/optimize-long-tasks/#yield-only-when-necessary) и [Scheduler](https://web.dev/optimize-long-tasks/#a-dedicated-scheduler-api). `isInputPending` - это функция, которая возвращает логическое значение - индикатор того, что ожидается пользовательский ввод. Если возвращается `true`, необходимо переключиться на основной поток для обработки пользовательского ввода.

Scheduler API - более продвинутая техника, позволяющая планировать задачи на основе системы приоритетов, принимающей во внимание то обстоятельство, видна ли пользователю выполняемая работа или же она выполняется в фоновом режиме.

Разделение длительных задач предоставляет браузеру больше возможностей для своевременной обработки действий пользователя и рендеринга обновлений.

### Лишний JS

В настоящее время веб-приложения используют больше JS, чем когда бы то ни было. И в ближайшее время ситуация вряд ли изменится.

Несколько рекомендаций по уменьшению количества JS:

- используйте [инструмент покрытия](https://developer.chrome.com/docs/devtools/coverage/) (coverage tool) инструментов разработчика для обнаружения неиспользуемого кода. Уменьшение количества ресурсов, загружаемых при запуске приложения, приводит к тому, что приложение тратит меньше времени на парсинг и компиляцию кода, что, в свою очередь, приводит к более плавному пользовательскому опыту (это особенно актуально для первого впечатления пользователя от взаимодействия с приложением);
- иногда код, помеченный как "неиспользуемый" инструментом покрытия, не используется при запуске приложения, но необходим для другого функционала. Такой код можно вынести в отдельную сборку с помощью [разделения кода](https://web.dev/reduce-javascript-payloads-with-code-splitting/);
- при использовании менеджера тегов убедитесь, что [теги периодически проверяются на предмет оптимизации](https://web.dev/tag-best-practices/) или даже на предмет "используемости". Старые теги с неиспользуемым кодом могут быть удалены, что сделает менеджер тегов меньше и эффективнее.

### Рендеринг больших обновлений

JS - это не единственная вещь, которая может влиять на отзывчивость приложения. Дорогой (с точки зрения вычислений) задачей может стать рендеринг - рендеринг больших обновлений может негативно влиять на скорость реакции приложения на действия пользователя.

Несколько рекомендаций на этот счет:

- не используйте `requestAnimationFrame()` для невидимой работы, т.е. работы, не связанной с обновлением пользовательского интерфейса. Вызовы `requestAnimationFrame()` обрабатываются на стадии рендеринга цикла событий. Когда на этой стадии выполняется слишком много работы, рендеринг обновлений может быть отложен;
- [сохраняйте ваш DOM маленьким](https://developer.chrome.com/docs/lighthouse/performance/dom-size/). Размер DOM напрямую связан с объемом работы по формированию макета. Чем меньше DOM, тем меньше работы нужно выполнить для обновления макета;
- используйте [CSS Containment](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Containment). CSS Containment позволяет браузеру изолировать поддерево DOM (определенное в свойстве `contain`) от остальной части страницы и исключить его из процессов формирования макета и рендеринга без необходимости. Свойство `content-visibility` позволяет браузеру пропускать рендеринг элементов, находящихся за пределами области видимости.

Ссылки для дальнейшего изучения:

- [оптимизация LCP](https://web.dev/optimize-lcp/);
- [оптимизация CLS](https://web.dev/optimize-cls/);
- [оптимизация FID](https://web.dev/optimize-fid/);
- [оптимизация INP](https://web.dev/optimize-inp/).

Надеюсь, что вы, как и я, узнали что-то новое и не зря потратили время.

Благодарю за внимание и happy coding!
